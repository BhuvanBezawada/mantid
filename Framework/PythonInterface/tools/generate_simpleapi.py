#  This file is part of the mantid workbench.
#
#  Copyright (C) 2018 mantidproject
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

# std imports
import os.path as osp
import logging

# 3rd party
from six import iteritems

# local imports
from mantid.api import (AlgorithmFactoryImpl as AlgorithmFactory,
    AlgorithmManagerImpl as AlgorithmManager,
    FrameworkManagerImpl as FrameworkManager
)

LOGGER = logging.getLogger("generate_simple_api")


AUTOGENERATED_PATH = osp.join(osp.dirname(osp.dirname(__file__)),
                              'mantid', 'simpleapi', 'generated.py')

MODULE_HEADER = """# This module was autogenerated by generate_simpleapi.py.  Do not edit as
# changes will be lost
from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

from . import lhs
from . import utils

"""

AUTOGEN_MSG = """
# This function was autogenerated by generate_simpleapi.py.  Do not edit as
# changes will be lost"""


TEMPLATE = AUTOGEN_MSG + '''
def {funcname}({funcargspec}Version={maxvers}, StartProgress=0.0, EndProgress=1.0,
{argindent}EnableLogging=True, StoreInADS=True):
    """
{docstring}
    """
    algm = utils.create_algorithm(b"{funcname}", Version, StartProgress, EndProgress,
                                  EnableLogging, StoreInADS)
    
    kwargs = dict({kwargs})
    kwargs = utils.merge_lhs_args(algm, lhs.lhs_info()[1], kwargs)  
    utils.set_properties(algm, kwargs=kwargs)
    algm.execute()
    return utils.gather_returns({funcname}, lhs, algm)
'''

EXCLUDED = ["Load", "StartLiveData", "CutMD", "RenameWorkspace"]


def autogenerated_algorithms(factory):
    """
    :return: A dict of {name:(versions...)) for each algorithm that is to
    have its api function generated
    """
    registered_algs = factory.getRegisteredAlgorithms(True)
    for name in EXCLUDED:
        registered_algs.pop(name, None)
    return registered_algs


def argspec(algm):
    """
    Generate an argspec suitable for the api function from the given
    algorithm object

    :param algm: An algorithm function
    :return: A 2-tuple of (argspec, kwargs dict}
    """
    ordered_alg_props = algm.mandatoryProperties()
    # args defines the list of arguments, including =default_value for those that have one
    # kwargs is to be used to fill a dict constructor that maps the names to the values
    # and allows the auto-generated function to use a kwargs dict as if the
    # function definition contained one
    args, kwargs = [], []
    for name in ordered_alg_props:
        prop = algm.getProperty(name)
        kwargs.append('{}={}'.format(name, name))
        # Mandatory parameters are those for which the default value is not valid
        if isinstance(prop.isValid, str):
            valid_str = prop.isValid
        else:
            valid_str = prop.isValid()
        if len(valid_str) > 0:
            args.append(name)
        else:
            # None is not quite accurate here, but we are reproducing the
            # behavior found in the C++ code for SimpleAPI.
            args.append('{}=None'.format(name))

    argspec = ', '.join(args) + ', '
    kwargs = ', '.join(kwargs)
    return argspec, kwargs


def generate_algorithm_function(manager, name, versions):
    """
    Generate the simpleapi wrapper function for the given algorithm
    :param name: The name of the algorithm
    :param versions: The range of versions to inspect
    :return: A string defining the algorithm function definition
    """
    algm = manager.createUnmanaged(name, max(versions))
    algm.initialize()
    arg_spec, kwargs = argspec(algm)
    definition = TEMPLATE.format(funcname=name,
                                 funcargspec=arg_spec,
                                 maxvers=max(versions),
                                 argindent=' ' * (len(name) + 5),
                                 kwargs=kwargs,
                                 docstring=algm.docString())
    return definition


def main():
    logging.basicConfig(level=logging.WARN, format="%(levelname)s:%(message)s")

    # start the framework to load all of the plugins
    FrameworkManager.Instance()  # noqa
    alg_factory = AlgorithmFactory.Instance()
    autogen_src = autogenerated_algorithms(alg_factory)
    alg_manager = AlgorithmManager.Instance()

    autogen_src = {b'Rebin': (1,)}

    generated_api = []
    LOGGER.info('Beginning simpleapi generation\n')
    for name, versions in iteritems(autogen_src):
        LOGGER.info("Generating api function for '{}'".format(name))
        generated_api.append(generate_algorithm_function(alg_manager, name, versions))
    LOGGER.info('Finished simpleapi generation')

    print('\n'.join(generated_api))

    # with open(AUTOGENERATED_PATH, 'w') as fid:
    #     fid.write(MODULE_HEADER)
    #     fid.write('\n'.join(generated_api))


if __name__ == '__main__':
    main()